

#' Read EMOTE data from a ZIP archive containing multiple EmoteConv output directories
#' @param zip.file filename of the ZIP archive to load. The ZIP archive may contain multiple directories generated by EmoteConv.
#' @param ambig a logical specifying weither to load ambiguous or unambiguously counts
#' @return a SummarizedExperiment object with two assays "N" and "Q" respectively storing raw counts and quantitative values.
#'         Seqnames store path of the file the value.
#' @export
#' @import IRanges
#' @import GenomicRanges
#' @author Julien Prados
EMOTE_readConvOutput <- function(zip.file,ambig=FALSE) {

  # Extract filenames to load from zip archives
  zip.filelist <- unzip(zip.file,list=TRUE)$Name
  zip.filelist <- zip.filelist[!grepl("^\\.",basename(zip.filelist))]
  pos.file <- grep("UnambPosTable.csv$",zip.filelist,value=TRUE,ignore.case=TRUE)
  neg.file <- grep("UnambNegTable.csv$",zip.filelist,value=TRUE,ignore.case=TRUE)
  if (ambig) {
    pos.file <- setdiff(grep("AmbPosTable.csv$",zip.filelist,value=TRUE,ignore.case=TRUE),pos.file)
    neg.file <- setdiff(grep("AmbNegTable.csv$",zip.filelist,value=TRUE,ignore.case=TRUE),neg.file)
  }
  ss.file <- grep("EmoteBarcode(s?)Report.(txt|csv)$",zip.filelist,value=TRUE,ignore.case=TRUE)

  # Load sample sheets from zip archive
  read.sample.sheet.from.zip <- function(f) {
    txt <- readLines(unz(zip.file,f))
    txt <- txt[grep("^(Emote_Barcode|D6[A-Z])\t",txt)]
    sample_sheet <- read.table(text=txt,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE,quote='"',row.names="Emote_Barcode",comment="")
    names(sample_sheet)[names(sample_sheet)=="Total emote barcode reads"] <- "Total_emote_barcode_reads"
    names(sample_sheet)[names(sample_sheet)=="Unmapped Reads"] <- "Unmapped_reads"
    sample_sheet <- sample_sheet[c("Total_emote_barcode_reads","Unmapped_reads")]
    sample_sheet
  }
  cat("loading",ss.file,"...\n")
  sample_sheet <- lapply(ss.file,read.sample.sheet.from.zip)
  sample_sheet <- setNames(sample_sheet,dirname(ss.file))
  bc <- sapply(sample_sheet,"rownames")
  if (!all(bc==bc[,1])) stop("barcodes not synchronised in all sample sheets")
  sample_sheet <- cbind(
    Total_emote_barcode_reads=rowSums(sapply(sample_sheet,'[[',"Total_emote_barcode_reads")),
    Unmapped_reads=rowSums(sapply(sample_sheet,'[[',"Unmapped_reads"))
  )
  rownames(sample_sheet) <- bc[,1]

  # Load EMOTE tables from ZIP archive
  read.emote.table.from.zip <- function(f) read.table(unz(zip.file,f),sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE,quote='"',fill=TRUE,comment="")
  cat("loading",pos.file,"...\n")
  pos <- setNames(lapply(pos.file,read.emote.table.from.zip),dirname(pos.file))
  pos <- stack(SplitDataFrameList(pos),"path")

  cat("loading",neg.file,"...\n")
  neg <- setNames(lapply(neg.file,read.emote.table.from.zip),dirname(neg.file))
  neg <- stack(SplitDataFrameList(neg),"path")


  x <- rbind(pos,neg)
  Q <- as.matrix(x[grep("^D6.+_Q$",names(x),value=TRUE)])
  colnames(Q) <- sub("_Q","",colnames(Q))
  N <- as.matrix(x[colnames(Q)])
  E <- SummarizedExperiment(
    SimpleList(N=N,Q=Q),
    rowRanges=GRanges(x$path,IRanges(x$Genomic_pos,width=1),strand=unname(c(plus="+",minus="-")[x$Strand]),nuc5p=RNAStringSet(x$X5._base))
  )

  sample_sheet <- sample_sheet[match(colnames(E),rownames(sample_sheet)),,drop=FALSE]
  rownames(sample_sheet) <- colnames(E)
  colData(E) <- DataFrame(sample_sheet)

  return(E)
}






# The code of lib_TSS to implement
#
# require(matrixStats)
# require(Biobase)
# require(Rsamtools)
# require(GenomicRanges)
# require(GenomicAlignments)
# require(GenomicFeatures)
# require(VGAM)
#
# source("src/lib_EMOTE_data.R")
#
#
#
#
# detect.tss <- function(env) {
#   with(env,{
#     rowRanges(TSS)$isGoodTSS.max.posQ <- simplify2array(mclapply(mc.cores=4,RppH.replicates,function(v) {rowMaxs(assay(TSS[,RppH[v,"+"]],"Q"))}))
#     rowRanges(TSS)$isGoodTSS.p <- simplify2array(mclapply(mc.cores=4,RppH.replicates,function(v) {
#       # combine p-values of replicates with Fisher's method
#       P <- rowRanges(TSS)$isTSS.p[,v,drop=FALSE]
#       x2 <- -2*rowSums(log(pmax(P,1e-30)))
#       pchisq(x2,2*ncol(P),lower.tail = FALSE)
#     }))
#     rowRanges(TSS)$isGoodTSS.min.p <- simplify2array(mclapply(mc.cores=4,RppH.replicates,function(v) {rowMins(rowRanges(TSS)$isTSS.p[,v,drop=FALSE])}))
#
#     rowRanges(TSS)$isGoodTSS.adjusted.p <- rowRanges(TSS)$isGoodTSS.p
#     rowRanges(TSS)$isGoodTSS.adjusted.p[rowRanges(TSS)$isGoodTSS.max.posQ<5] <- NA
#     rowRanges(TSS)$isGoodTSS.adjusted.p <- apply(rowRanges(TSS)$isGoodTSS.adjusted.p,2,p.adjust,method="fdr")
#
#     rowRanges(TSS)$isGoodTSS <- !is.na(rowRanges(TSS)$isGoodTSS.adjusted.p) & rowRanges(TSS)$isGoodTSS.adjusted.p<0.01
#
#     # Select the subset of TSS sites that are valid candidates
#     tss <- TSS[rowSums(rowRanges(TSS)$isGoodTSS)>0]
#     tss <- tss[order(rowRanges(tss))]
#   })
# }
#
# annotate.tss <- function(env) {
#   with(env,{
#     rowRanges(tss)$log10minP <- pmin(-log10(rowMins(rowRanges(tss)$isGoodTSS.adjusted.p,na.rm=TRUE)),30)
#
#     # annotate TSS with the following gene informations
#     rowRanges(tss)$isInsideAGene <- countOverlaps(tss,gff)
#
#     orf <- promoters(gff,0,1)
#     nn <- precede(tss,orf)
#     rowRanges(tss)$followingGeneID[!is.na(nn)] <- orf[nn[!is.na(nn)]]$ID
#     rowRanges(tss)$followingGeneName[!is.na(nn)] <- orf[nn[!is.na(nn)]]$Name
#     rowRanges(tss)$followingGeneDistance[!is.na(nn)] <- distance(tss[!is.na(nn)],orf[nn[!is.na(nn)]])
#     rm(nn,orf)
#
#     if (exists("sRNA")) {
#       orf <- promoters(sRNA,0,1)
#       nn <- nearest(tss,orf)
#       rowRanges(tss)$nearestStartingSmallRnaName[!is.na(nn)] <- orf[nn[!is.na(nn)]]$subject_seq_id
#       rowRanges(tss)$nearestStartingSmallRnaDistance[!is.na(nn)] <- distance(tss[!is.na(nn)],orf[nn[!is.na(nn)]])
#       rm(nn,orf)
#     }
#
#     # Retreive promoter sequences of TSS from FASTA
#     rowRanges(tss)$seq <- local({
#       seq.gr <- granges(restrict(promoters(rowRanges(tss),45,5),start=seqlengths(fa)*0+1,end=seqlengths(fa)[seqlevels(tss)]))
#       seq <- getSeq(fa,seq.gr)
#       seq50 <- DNAStringSet(rep(paste0(rep("N",50),collapse=""),length(seq)))
#       subseq(seq50,51-nchar(seq),50) <- seq
#       seq50
#     })
#
#
#     # Test for presence of the TATAAT box in the sequence between pos -5 to -15
#     rowRanges(tss)$TATAAT <- local({
#       pos <- c(-11,-10,-12,-9,-13)
#       ed <- t(neditAt("TATAAT",rowRanges(tss)$seq,at=45 + pos))
#       i <- cbind(1:nrow(ed),max.col(-ed))
#       cbind(pos = pos[i[,2]], err = ed[i])
#     })
#
#     # Test for presence of the TATAAT box in the sequence between pos -25 to -44
#     rowRanges(tss)$TTGACA <- local({
#       pos <- c(-37,-36,-38,-35,-39,-34,-40,-33,-41,-32,-42)
#       ed <- t(neditAt("TTGACA",rowRanges(tss)$seq,at=45 + pos))
#       i <- cbind(1:nrow(ed),max.col(-ed))
#       cbind(pos = pos[i[,2]],err = ed[i])
#     })
#
#     # Generate the pattern that show matching sequences with uppercase letters in a lowercase letter DNA sequence
#     rowRanges(tss)$pattern <- tolower(rowRanges(tss)$seq)
#     subseq(rowRanges(tss)$pattern,45+rowRanges(tss)$TATAAT[,"pos"],width=6) <- toupper(subseq(rowRanges(tss)$pattern,45+rowRanges(tss)$TATAAT[,"pos"],width=6))
#     subseq(rowRanges(tss)$pattern,45+rowRanges(tss)$TTGACA[,"pos"],width=6) <- toupper(subseq(rowRanges(tss)$pattern,45+rowRanges(tss)$TTGACA[,"pos"],width=6))
#     subseq(rowRanges(tss)$pattern,46,width=5) <- toupper(subseq(rowRanges(tss)$pattern,46,width=5))
#     rowRanges(tss)$TATAAT.seq <- subseq(rowRanges(tss)$seq,45+rowRanges(tss)$TATAAT[,"pos"],width=6)
#     rowRanges(tss)$TTGACA.seq <- subseq(rowRanges(tss)$seq,45+rowRanges(tss)$TTGACA[,"pos"],width=6)
#     rowRanges(tss)$TGT_TATAAT.seq <- subseq(rowRanges(tss)$seq,45+rowRanges(tss)$TATAAT[,"pos"]-3,width=3)
#   })
# }
#
#
#
# cluster.tss <- function(env) {
#   with(env,{
#     # define TSS regions by grouping TSS that are less than 50bp away one from another
#     # and elect a representant (the TSS with smallest p-value)
#     TSS.regions <- reduce(rowRanges(tss),min.gapwidth=5,with.revmap=TRUE)
#     TSS.regions$p <- extractList(rowMins(rowRanges(tss)$isGoodTSS.p),TSS.regions$revmap)
#     TSS.regions$representing <- unlist(TSS.regions$revmap[rank(TSS.regions$p,ties.method = "first")==1])
#     TSS.regions$representing.pos <- unlist(which(TSS.regions$revmap==TSS.regions$representing))
#     TSS.regions$representing.pos[as.vector(strand(TSS.regions)=="-")] <- with(TSS.regions[as.vector(strand(TSS.regions)=="-")],elementLengths(revmap)+1-representing.pos)
#
#     rowRanges(tss)$TSS.region.id <- findOverlaps(rowRanges(tss),TSS.regions,select = "first")
#     rowRanges(tss)$TSS.region.size <- elementLengths(TSS.regions$revmap)[rowRanges(tss)$TSS.region.id]
#     rowRanges(tss)$is.representing.TSS.region <- seq_along(rowRanges(tss)) %in% TSS.regions$representing
#
#     # derterine the specific TSS and the specific clusters
#     TSS.regions$hasAnyGood <- sapply(colnames(rowRanges(tss)$isGoodTSS),function(nm) {any(extractList(rowRanges(tss)$isGoodTSS[,nm],TSS.regions$revmap))})
#     rowRanges(tss)$isSpecificTSS <- rowRanges(tss)$isGoodTSS & (rowSums(rowRanges(tss)$isGoodTSS)==1)
#     TSS.regions$isAllSpecific <- sapply(colnames(rowRanges(tss)$isSpecificTSS),function(nm) {all(extractList(rowRanges(tss)$isSpecificTSS[,nm],TSS.regions$revmap))})
#     TSS.regions$hasAnySpecific <- sapply(colnames(rowRanges(tss)$isSpecificTSS),function(nm) {any(extractList(rowRanges(tss)$isSpecificTSS[,nm],TSS.regions$revmap))})
#     colnames(TSS.regions$isAllSpecific) <- colnames(TSS.regions$hasAnySpecific) <- colnames(rowRanges(tss)$isSpecificTSS)
#
#     # show position of the representing element within the TSS region
#     write.table(table(elementLengths(TSS.regions$revmap),TSS.regions$representing.pos),sep="\t",col.names=NA)
#   })
# }
#
#
# emote2tss <- function(env) {
#   normalize.and.fit.tss.model(env)
#   detect.tss(env)
#   annotate.tss(env)
#   cluster.tss(env)
# }
#
